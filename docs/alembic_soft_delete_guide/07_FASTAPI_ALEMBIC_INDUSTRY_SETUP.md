# FastAPI + Alembic: Industry Best Practices & Setup from Scratch

> **Context for this guide:** You ran FastAPI first (which called `init_db()` →
> `Base.metadata.create_all()`), then set up Alembic. The first autogenerated
> revision had `pass` in both `upgrade` and `downgrade` because the database
> already matched the models — Alembic saw no diff. This guide explains why that
> happened and the correct canonical workflow.

---

## Table of Contents

1. [The Root Problem: Two Schema Managers Fighting](#1-the-root-problem)
2. [Industry Best Practice: Alembic Is the Single Source of Truth](#2-industry-best-practice)
3. [Should You Keep `init_db()`?](#3-should-you-keep-init_db)
4. [Step-by-Step: Alembic + FastAPI Workflow](#4-step-by-step-workflow)
5. [Fresh Start: Delete Everything and Set Up Correctly](#5-fresh-start)
6. [Why Your First Revision Had `pass` in Both Directions](#6-why-pass)
7. [Quick Reference Cheat Sheet](#7-cheat-sheet)

---

## 1. The Root Problem

```
Timeline of what you did
────────────────────────

  [1] Define models (models.py)
  [2] Run FastAPI → lifespan calls init_db()
        → Base.metadata.create_all()
        → SQLite file (todos.db) created with correct tables
  [3] Set up Alembic
  [4] alembic revision --autogenerate
        → Alembic compares models vs DB
        → Tables already exist and match → NO DIFF
        → upgrade(): pass   downgrade(): pass   ← empty migration
  [5] You now have a DB managed by BOTH init_db() AND Alembic
        → Two schema managers → inconsistencies guaranteed over time
```

`create_all()` and Alembic **both manage schema**. When they coexist:

| Scenario | What happens |
|---|---|
| New column added to model | Alembic migration creates it; `create_all()` also tries to (silently skips existing columns) |
| Column removed from model | Alembic migration drops it; `create_all()` ignores drops entirely — column stays |
| Table dropped via Alembic downgrade | Next `create_all()` silently re-creates it |

The result: **divergence**. Real bugs appear in production months later.

---

## 2. Industry Best Practice

The standard across Django (migrations), Rails (ActiveRecord migrations), and
SQLAlchemy projects is the same principle:

> **One tool owns the schema. In production, that tool is the migration system (Alembic).**

```
┌─────────────────────────────────────────────────────────────┐
│  RULE: Once Alembic is in your project, it owns the schema.  │
│  Never call Base.metadata.create_all() in production code.   │
└─────────────────────────────────────────────────────────────┘
```

### What the industry does instead

```
Development loop:
  1. Edit model in models.py
  2. alembic revision --autogenerate -m "add column X to todos"
  3. Review the generated file in alembic/versions/
  4. alembic upgrade head
  5. Run FastAPI — no schema creation inside the app itself

Deployment (CI/CD):
  1. git pull (new code includes new migration files)
  2. alembic upgrade head      ← runs before app starts
  3. Start FastAPI workers
```

### Acceptable uses of `create_all()` / `init_db()`

| Context | OK? | Reason |
|---|---|---|
| Production FastAPI lifespan | ❌ No | Alembic owns schema |
| Unit tests (in-memory SQLite) | ✅ Yes | Tests spin up/down their own fresh DB |
| Local prototyping (no Alembic yet) | ✅ Yes | Throw-away, no migration history |
| After Alembic is set up | ❌ No | Conflicts with migration state |

---

## 3. Should You Keep `init_db()`?

### Short answer: Remove it from the FastAPI lifespan once Alembic is set up.

### Option A — Alembic runs separately (recommended for teams / production)

```python
# main.py — clean lifespan, no schema management
@asynccontextmanager
async def lifespan(app: FastAPI):
    print("Starting up...")
    # Schema is already up to date because deployment script ran:
    #   alembic upgrade head
    # before this process started. Nothing to do here.

    if settings.debug:
        seed_db()   # seeding is fine to keep

    yield
    print("Shutting down...")
```

Alembic is invoked **outside the app**, in a deploy script or Makefile:

```bash
# Makefile target
migrate:
    uv run alembic upgrade head

run:
    uv run uvicorn main:app --reload
```

### Option B — Alembic runs programmatically inside lifespan (acceptable for solo/small projects)

```python
# main.py
from alembic import command
from alembic.config import Config

@asynccontextmanager
async def lifespan(app: FastAPI):
    print("Starting up...")
    # Run any pending migrations on startup
    alembic_cfg = Config("alembic.ini")
    command.upgrade(alembic_cfg, "head")
    print("✅ Database schema is up to date")

    if settings.debug:
        seed_db()

    yield
    print("Shutting down...")
```

**Tradeoff of Option B:**
- ✅ Convenient — DB is always current when app starts
- ❌ Migrations run on every worker restart (annoying in dev with `--reload`)
- ❌ Multiple workers race on startup in production → use a pre-start script instead

### Which to pick?

| You are... | Use |
|---|---|
| Solo project, learning | Option B (convenient) |
| Team project, any real deployment | Option A (explicit, predictable) |

---

## 4. Step-by-Step Workflow

### Phase 1: First-time project setup (before any DB exists)

```
Step 1: Define your models in models.py
Step 2: Configure alembic/env.py to point at Base.metadata (already done in your project)
Step 3: Generate the initial migration
          alembic revision --autogenerate -m "initial"
Step 4: Open the generated file in alembic/versions/ and VERIFY it
          upgrade()   → should have op.create_table(...)
          downgrade() → should have op.drop_table(...)
Step 5: Apply the migration (this creates the DB and tables)
          alembic upgrade head
Step 6: Start FastAPI — no init_db() in lifespan
          uv run uvicorn main:app --reload
```

### Phase 2: Adding a new feature (changing the schema)

```
Step 1: Edit models.py (add column, new table, rename, etc.)
Step 2: Generate migration
          alembic revision --autogenerate -m "add priority column to todos"
Step 3: Review the generated file
          upgrade()   → op.add_column(...)
          downgrade() → op.drop_column(...)
Step 4: Apply the migration
          alembic upgrade head
Step 5: Continue developing — FastAPI picks up the new schema
```

### Phase 3: Rolling back a mistake

```
# See current state
alembic current

# See history
alembic history --verbose

# Downgrade one step
alembic downgrade -1

# Downgrade to a specific revision
alembic downgrade 2026_02_20_001
```

### Autogenerate always requires human review

Alembic autogenerate is powerful but **not 100% reliable**. Always review
the generated file before applying it.

```
Common cases where autogenerate gets it wrong:
  ❌ Column renames   → looks like DROP + ADD (data loss!)
  ❌ Table renames    → same problem
  ❌ Some constraint types on SQLite
  ✅ Add column
  ✅ Drop column
  ✅ Create table
  ✅ Drop table
  ✅ Add/drop index
```

---

## 5. Fresh Start — Delete Everything and Set Up Correctly

> **Goal:** Nuke the existing DB and Alembic history, then rebuild the right way.

### Step 1: Stop FastAPI if it is running

```bash
# Ctrl+C in the uvicorn terminal
```

### Step 2: Delete the database file

```bash
# from workshop/00_personal_todo/
rm -f todos.db
```

### Step 3: Delete all migration version files

```bash
rm -f alembic/versions/*.py
# keep __pycache__ deletion optional
find alembic/versions/__pycache__ -name "*.pyc" -delete 2>/dev/null || true
```

### Step 4: Remove `init_db()` from the FastAPI lifespan

Edit `main.py`:

```python
# BEFORE (what you have now)
@asynccontextmanager
async def lifespan(app: FastAPI):
    print("Starting up the application...")
    init_db()           # ← REMOVE THIS
    if settings.debug:
        seed_db()
    yield
    print("Shutting down the application...")
```

```python
# AFTER (correct)
@asynccontextmanager
async def lifespan(app: FastAPI):
    print("Starting up the application...")
    # Schema is managed by Alembic. Run: alembic upgrade head
    # before starting the application.
    if settings.debug:
        seed_db()
    yield
    print("Shutting down the application...")
```

You can also remove the `init_db` import from `main.py`:

```python
# Remove this line from imports:
from core.database import init_db, seed_db
# Replace with:
from core.database import seed_db
```

### Step 5: Generate a clean initial migration

```bash
cd workshop/00_personal_todo
uv run alembic revision --autogenerate -m "initial"
```

### Step 6: Verify the generated migration

Open the new file in `alembic/versions/`. It **must** look like this:

```python
def upgrade() -> None:
    op.create_table(
        'todos',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('title', sa.String(length=255), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('is_completed', sa.Boolean(), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), ...),
        sa.PrimaryKeyConstraint('id'),
    )
    op.create_index(op.f('ix_todos_id'), 'todos', ['id'], unique=False)

def downgrade() -> None:
    op.drop_index(op.f('ix_todos_id'), table_name='todos')
    op.drop_table('todos')
```

If you see `pass` in `upgrade()` — stop. Something is wrong (see Section 6).

### Step 7: Apply the migration (this creates the DB)

```bash
uv run alembic upgrade head
```

Expected output:
```
INFO  [alembic.runtime.migration] Running upgrade  -> 2026_02_21_001, initial
```

### Step 8: Verify the DB was created correctly

```bash
# Check alembic_version table has your revision
uv run python -c "
import sqlite3
conn = sqlite3.connect('todos.db')
print('Tables:', conn.execute(\"SELECT name FROM sqlite_master WHERE type='table'\").fetchall())
print('Version:', conn.execute('SELECT * FROM alembic_version').fetchall())
conn.close()
"
```

Expected output:
```
Tables: [('todos',), ('alembic_version',)]
Version: [('2026_02_21_001',)]
```

### Step 9: Start FastAPI

```bash
uv run uvicorn main:app --reload
```

FastAPI starts. No `init_db()` is called. The schema was already set by Alembic.

---

## 6. Why Your First Revision Had `pass` in Both Directions

This is the classic "DB already exists" problem:

```
Autogenerate works by comparison:
  models.py   ←→   current DB state
  (what SHOULD be)  (what IS)

When init_db() already ran → DB already has the tables → diff = nothing
→ upgrade():   pass
→ downgrade(): pass

Alembic is not wrong — it just found no difference to migrate.
The fix is what Section 5 describes: delete the DB, then autogenerate.
```

If you cannot delete the DB (production data exists), the correct approach is:
stamp the current state as a baseline, then manage future changes via Alembic.
That approach is documented in `06_EXISTING_DATABASE_SETUP.md`.

---

## 7. Quick Reference Cheat Sheet

```bash
# ─── First time setup ───────────────────────────────────────────
rm todos.db                                          # delete old DB
rm alembic/versions/*.py                             # clear migrations
# remove init_db() from main.py lifespan
uv run alembic revision --autogenerate -m "initial"  # generate migration
# review alembic/versions/<new_file>.py
uv run alembic upgrade head                          # apply (creates DB)
uv run uvicorn main:app --reload                     # start FastAPI

# ─── Adding a new model/column ──────────────────────────────────
# edit models.py
uv run alembic revision --autogenerate -m "add X"
# review the generated file
uv run alembic upgrade head

# ─── Inspecting state ───────────────────────────────────────────
uv run alembic current          # which revision the DB is at
uv run alembic history          # full migration chain
uv run alembic show head        # details of the latest revision

# ─── Rolling back ───────────────────────────────────────────────
uv run alembic downgrade -1     # one step back
uv run alembic downgrade base   # all the way back (drops all tables)
```

### The golden rule

```
┌──────────────────────────────────────────────────────────────────────┐
│  Schema lifecycle order (always):                                     │
│                                                                       │
│  1. Edit model in models.py                                          │
│  2. alembic revision --autogenerate -m "description"                 │
│  3. Review generated file                                            │
│  4. alembic upgrade head                                             │
│  5. Start FastAPI (no create_all inside the app)                     │
└──────────────────────────────────────────────────────────────────────┘
```

---

*Created: 2026-02-21*
